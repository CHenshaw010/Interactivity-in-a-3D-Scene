## This C++ Repository contains multiple OpenGL applications that provide Interactivity in a 3D scene.

## Navigation:
<details>
<summary>Interactive 3D Environment:</summary>

- [Design Defense Document](https://github.com/CHenshaw010/Interactivity-in-a-3D-Scene/blob/main/Design_Defense.pdf)
- [Camera Implementation](https://github.com/CHenshaw010/Interactivity-in-a-3D-Scene/blob/cd8bc55b90388ddae904782ea5357dc088dec1ee/Interactive%203D%20Environment/camera.h)
- [Texture Rendering](https://github.com/CHenshaw010/Interactivity-in-a-3D-Scene/blob/cd8bc55b90388ddae904782ea5357dc088dec1ee/Interactive%203D%20Environment/7-1%20Project%20-%20Submission.cpp#L552)
- [Lighting Calculations](https://github.com/CHenshaw010/Interactivity-in-a-3D-Scene/blob/cd8bc55b90388ddae904782ea5357dc088dec1ee/Interactive%203D%20Environment/7-1%20Project%20-%20Submission.cpp#L149)
- [3D Object Meshes](https://github.com/CHenshaw010/Interactivity-in-a-3D-Scene/blob/main/Interactive%203D%20Environment/meshes.cpp)
</details>

<details>
<summary>Simple 3D Environment:</summary>
  
[3D Object Meshes](https://github.com/CHenshaw010/Interactivity-in-a-3D-Scene/blob/cd8bc55b90388ddae904782ea5357dc088dec1ee/Simple%203D%20Environment/3-3%20Assignment%20-%20Building%20a%203D%20Pyramid.cpp#L243)

</details>

### Important Note:
This application currently does not work due to OpenGL dependency issues. While I'm actively working to solve this issue, the repository stands to demonstrate the coding capabilities within OpenGL.

### Personal Notes:
- How do I approach designing software and developing programs?
  - I approach designing software methodically. First, it is highly important to understand the scope of the project and the requirements to be implemented. This is helpful in determining early as any questions can be answered and supplemental details can be obtained. From there, the software should be designed so data structures, conditional statements, etc. can be identified wherever necessary. During implementation, I find the best approach in designing software is to build incrementally and run often. This ensures that any errors or unintended actions can be caught early and their origin identified easily. In this project, I first looked to the rubric to gain as deep an understanding of the requirements. Then, I brainstormed and designed the required functionality to meet the requirements. If code was repeated in sections, they could be consolidated into new functions to enhance maintainability. Afterwards, I worked incrementally in developing objects, camera system, light sources, and more frequently running to verify the results were as intended. This project reinforced strong coding practices but also taught me new design skills that will be useful in future software projects. I learned how to create object meshes in OpenGL, apply multiple variations of realistic light sources, add a dynamic camera system, and apply textures to objects. I utilized a wide array of primitive objects that can further be used to create extremely complex objects. The principles of object oriented programming (OOP) were instrumental in ensuring the code was reliable, consolidated, maintainable, and readable.

- How can computer science help me in reaching my goals?
  - These skills will be very valuable depending on where I end up professionally working with code. Object creation, textures, camera systems, and lighting are all necessary skill to create 3D scenes such as those in video games. Video game development is a career that I have always wanted to experience so these skills will be highly relevant there. Alternatively, OpenGL is a tool that can be fun to play around with for personal use by creating scenes that have no bounds such as recreating a room in a house or modeling plans for a house to be built upon. However, the most important skill that was reinforced that will be very valuable in both my educational and professional pathway is critical thinking. This class utilized a skill set that I had no previous experience in and, understandably, ran into many roadblocks. I learned a good amount of troubleshooting methods for the errors I had or if the program wasn't running as I had expected it to. It reinforced that an error is a learning opportunity and analyzing it can both fix the problem and grant knowledge about code.
